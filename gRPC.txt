DDD:
https://tproger.ru/articles/domain-driven-design-davajte-ne-budem-uslozhnyat

ПОсервис делиться на домены. Каждым из них занимается отдельная команда.
Домены в свою очередь делятся на субдомены — подобласти, которые отвечают за отдельные проблемы
Ограниченный Контекст.
Домены, субдомены - внутренние подобсласти
язык описания ддд - документация
Есть ядро продукта - core domain
связи между доменами:
    - Партнерство - где есть общее ядро, они тесно связанные этим
    - Потребитель-поставщик (Customer-Supplier). поставщик  всегда отзывчива к изменениям другой команды, а другая нет
    - прослойка между сервисами, когда один домен для расшифровки пакетов между доменами
    - и еще куча всяких

1) https://www.youtube.com/watch?v=NSN-NXfbEqM
https://habr.com/ru/companies/oleg-bunin/articles/537862/
    про DDD:
        описываются требования = бизнесс -> пишется код
        код должен в себе отражать предметную область, т.е. классы должны соответствовать объекам реального мира по структуре и поведению.
        т.е. код будет пониматься извне, типа все понятно, прям как описано в конфе.
        Один термен может иметь разное значение по бизнесу в разных доменах

    event storming
        Это способ собрть вместе разрабов и экспертов в бизнесе для увлекательного и быстрого исследования сложной предметной области.
        Наклеивают стикеры на стену. Вопросы/ответы.
        Структура Event Storming достаточно проста и многое взяла из DDD:
            Клиент инициирует выполнение команды, она в будушем времени, типа запрос на выполнение действия.
            Команда идет в агрегат - формируются данные, происходит валидация. Если все норм, то выполняется действие и создается событие уже в прошлом как факт.
            Команда может быть отменена, а действие нет.
            Эту схему зазвали big picture, типа картинка, которая обьясняет все.

            Собираются бизнес-спецы и тех отдел. Они размещают на доске все события, которые происходят в бизнесе.
            Например "Товар добавлен в корзину", "Товар оплачен","Доставка оформлена", "Доставлено", "Отказ".
            Затем к событиям приписываем команды "Добавить товар в корзину", "Оплатить" и тд.
            Из этого всего получается бизнесс-правила, типа что к чему идет.

            Появляются агрегаты - куча данных и связей между ними в одном объекте, где происходит валидация (типа целлостность и непротиворечивость).
            Чтоб понять, как делать агрегат, собирают команды и события, которые должны обрабатываться вместе.

            На доске обычно группируют Событие + команды + Бизнес-правила + агрегат

            Далее агрегаты собираются вместе и образуют то, что в DDD называется ограниченными контекстами. Они представляют из себя модель + общий словарь.
            Ограниченные контексты должны быть максимально автономными. Такая автономность помогает в их рамках делать независимые друг от друга микросервисы.

            ИЗ получившимися контекстами делают либо монолит либо микросерсисы с определенными границами.
            Главное чтобы не было зависимости по данным.

            Поддомены делят на 3 типа:
             - CORE - сердце бизнесса
             - SUPPORTING - жизненно необходимый для CORE
             - GENERIC - не критичная функциональность


        Базовые виды event storming:
            big picture: события ...
            process: события ...
            software disign: события, агрегаты



2) https://www.youtube.com/watch?v=dDArnlZ4VQw



1.7.1.2 CI/CD разбираться в том что есть в gitlab-ci.yaml , как это настраивается и работает
https://docs.gitlab.com/ee/ci/quick_start/

CI - сборка, упаковка и тестирование.
CD - автоматизирует развёртывание в разных окружениях.

Писать команды можно в файле gitlab-ci.yaml или где угодно а в этом файле прописать include и пути до команд.

1. Можно разбить на шаги, где шаг (стадия пайплайна) - stage, при билде build, test, при выкладке deploy.
Можно указать скрипт баш script
2. Artifacts - промежуточные сборки или файлы, которые могут передаваться от одного этапа к другому.
   Т.е. если мы хотим использовать в одном этапе то, что было сгенерировано до него, то мы должны сохранить это в качестве артефакта.
   Пример артефактов — скомпилированные бинарные файлы, архивы, образы контейнеров.
    path - путь до файла, где собираем эти данные
   Можно делать правила:
   when - позволяет задать простейшие условия запуска задания. Например, если мы хотим запускать его только вручную (manual)
   Это в простом случае.
   В сложном:
     rules:
       - if - условие
       - changes fileName - проверяет затронут ли файл. Это условие, если да, то продолжается дальше. Т.е. это тоже if по значению.
       - exists - существует ли что то
        и еще что то
3. extends - позволяет вынести часть сценария в отдельный блок и внедрить его в задания

4. !reference tags - позволяет описать сценарий и повторно его использовать для разных стадий и задач

    Мы создали задачу apt-cache. Точка в начале названия говорит системе, что данную задачу не нужно стартовать автоматически при запуске pipeline.
    Созданная задача состоит из двух секций script и after_script. Секций может быть больше.
    Мы выполняем стадию install. В одной из строк выполнения мы вызываем apt-cache (только команды из раздела script).
    При выполнении стадии update мы вызываем apt-cache два раза — первый выполняет команды раздела script, второй — after_script.

5. services - Опция позволяет запустить дополнительный docker-контейнер для задания, например БД


https://jira.fabrikant.ru/browse/ROSATOM-5864
https://git.fabrikant.ru/ets-applications/223smsp-ea-rosatom/-/merge_requests/167/diffs
https://git.fabrikant.ru/mailer/api/-/pipelines/214656

как делается на mailing-management ???

Ansible



                    1.3.2.1 объяснить всегда ли соблюдение принципов DRY/KISS/YAGNI - хорошо.
                    https://tproger.ru/articles/5-principov-chitaemogo-koda-kiss-yagni-dry-bduf-i-britva-okkama
                        1. YAGNI
                            You Aren’t Gonna Need It / Вам это не понадобится
                            Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже.
                            Если не нужно удаляй. Если понадобится в будущем - по гиту верни.
                        2. DRY
                        Don’t Repeat Yourself / Не повторяйтесь
                        Избегайте копирования кода.
                        Выносите общую логику вместо дублирования
                        Прежде чем добавлять функционал, проверьте в проекте, может, он уже создан.

                        3. KISS
                        Keep It Simple, Stupid / Будь проще
                        Этот принцип гласит, что простые системы будут работать лучше и надежнее.
                        Не делай того, что не просят.
                        Каждый метод решает одну проблему.
                        При модификации кода в будущем не должно возникнуть трудностей.
                        DDD - изначально оч сложный, и надо привыкать к нему. А потом будет просто.



                        1.3.3.1 Вязкость и связанность программного кода. Дать определения, предоставить примеры кода.
                        https://habr.com/ru/companies/oleg-bunin/articles/505170/
                        Тут рассказывается как делать абстракцию.
                        Связность - хорошо, а связанность - в плохом смысле.
                        Из-за связанности  ломая один объект, ломается и все связанные.
                        Как правильно формировать пакеты и как работать с зависимостями пакетов?

                         cohesion (связность) и coupling (связанность)

                         cohesion:  REP, CCP, CRP - как дизайнить код
                         coupling:  ADP, SDP, SAP - как использовать

                        Для того, чтобы понять, coupling у вас или cohesion, существуют проверочные правила.

                        Есть несколько принципов, отч его это зависит:
                         - REP: те пакеты, которые переиспользуются, надо делать как отдельный вендор
                         - CCP: Классы, которые изменяются по одной и той же причине, должны упаковываться в один пакет.
                         - CRP: То есть классы, которые используются вместе — упаковываем вместе.
                           Проверочное правило здесь такое: смотрим, используется ли в нашем софте всё из того пакета, который к нему подключен.
                           Если используется чуть-чуть, значит, скорее всего, пакет спроектирован неверно.

                        принципы использования:
                         - проверять циключескую зависимость пакетов. Тут главное, чтобы не было циклов, а граф.
                         Построить граф можно через библиотеку clue/graph-composer - ей скармливаешь пакет, и она строит гигантский граф со всеми зависимостями.

                        Как разорвать цикл:
                         - инверсия зависимости. Т.е. вместо класса изать интерфейс. Например redis и mysql там есть User. Делаем userInterface и там и там реализуем.
                         - выделить общие функионалы, которые юзают в разных пакетах, в отдельный вендор

                        Принцип стабильности зависимости:
                            Есть понятие нестабильности, котороые расчитывается по формуле.
                            Если на пакете завязалось много других пакетов разными спосбами, то скорее всего это не стабильно.
                            Чем больше абстрактных классов, тем стабильнее пакет. Тут еще означает, что этот класс не будет меняться.
                            От него может быть зависимы другие пакеты, И он не должен меняться часто, лучше никогда.
                            Стабильность тут означает как часто приходится менять пакеты при изменении абстрактных классов.
                            Абстрактыне пакеты должны быть стабильны, чтобы на них завязались другие пакеты.
                            Абстрактность — это число абстрактных классов и интерфейсов в пакете, деленное на общее число классов и интерфейсов в этом самом пакете:

                            Бывает что очень много абстрактных классов, но очень не стабильно. Тут слишком много интерфейсов (больше классов)
                            Но может быть и супер-неабстрактно и супер-стабильно - тут все супер.


1.6.1 Познакомиться с gRPC
https://wiki.merionet.ru/articles/chto-takoe-grpc-i-protobuf
https://habr.com/ru/companies/yandex/articles/484068/

RPC - это удаленные вызовы процедур - Remote Procedure Calls
Есть клиент, есть сервер.
Передача команд и параметров может быть в разных форматах:
JSON-rpc, XML-rpc, Sun-rpc - двоичный протокол на базе TCP и UDP - низкоуровневый.
Что такое gRPC - В 2015 году Google открыл исходный код своего проекта, который в конечном итоге получил название gRPC.
В 2015 году появился HTTP/2, который был создан Google для использования gRPC в его архитектуре.

HTTP/2:
    - Мультиплексирование запроса/ответ
      в http м.б. только один запрос и один ответ. В 2-й версии запрос ответ м.б. мультиплексированным
      с помощью так называемым binary framing. Сжимаются и шифруются боди и хэдэры.
      Этот двоичный уровень инкапсулирует и кодирует данные. На этом уровне HTTP-запрос/ответ разбивается на кадры (они же фреймы).
      Заголовки в фрейме такие же, как к http. Но они шифруются и не пересылаются те же самые.
      Данные могут слаться от разных серверов сразу, типа разбить отправку больших данных по серверам.
      Другие заголовки посылаются если только появилось отличие от предыдущих.
Protocol Buffer (Protobuf) - формат данных в gRPC. Есть формат данных и у клиента и у сервера и сообщение должны ему соответствовать.
Формат называется Контрактом обмена данных:
message Person {
    required string name = 1;
    required int32 id = 2;
    optional string email = 3;
}